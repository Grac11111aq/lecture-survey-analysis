#!/usr/bin/env python3
"""
Phase 2: 教育効果の統計的検証
ANALYSIS_PLAN.md の Phase 2 に従い実施:
- McNemar検定（対応のある二項データ）
- 対応のあるt検定（総合スコア）
- 効果量算出（Cohen's d）
- 多重比較補正
- サンプルサイズ・検出力分析
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go
from scipy import stats
from scipy.stats import mcnemar
import pingouin as pg
from statsmodels.stats.contingency_tables import mcnemar as sm_mcnemar
from statsmodels.stats.power import ttest_power
from statsmodels.stats.multitest import multipletests
import warnings
import os

warnings.filterwarnings('ignore')

class Phase2StatisticalTesting:
    def __init__(self, data_dir='data/analysis/'):
        self.data_dir = data_dir
        self.before_df = None
        self.after_df = None
        self.matched_df = None
        self.significance_level = 0.05
        
    def load_and_prepare_data(self):
        """データ読み込みと前処理"""
        print("=== Phase 2: データ準備 ===")
        
        self.before_df = pd.read_csv(os.path.join(self.data_dir, 'before_excel_compliant.csv'))
        self.after_df = pd.read_csv(os.path.join(self.data_dir, 'after_excel_compliant.csv'))
        
        # Page_IDでマッチング
        matched_before = self.before_df.set_index('Page_ID')
        matched_after = self.after_df.set_index('Page_ID')
        
        # 共通のPage_IDのみ抽出
        common_ids = matched_before.index.intersection(matched_after.index)
        
        self.matched_df = pd.DataFrame(index=common_ids)
        
        # Q1項目の対応関係
        q1_mapping = {
            'Saltwater': ('Q1_Saltwater_Response', 'Q1_Saltwater'),
            'Sugarwater': ('Q1_Sugarwater_Response', 'Q1_Sugarwater'),
            'Muddywater': ('Q1_Muddywater_Response', 'Q1_Muddywater'),
            'Ink': ('Q1_Ink_Response', 'Q1_Ink'),
            'MisoSoup': ('Q1_MisoSoup_Response', 'Q1_MisoSoup'),
            'SoySauce': ('Q1_SoySauce_Response', 'Q1_SoySauce')
        }
        
        # 正答基準
        self.correct_answers = {
            'Saltwater': True,
            'Sugarwater': True,
            'Muddywater': False,
            'Ink': False,
            'MisoSoup': True,
            'SoySauce': True
        }
        
        # マッチングデータの作成
        for substance, (before_col, after_col) in q1_mapping.items():
            self.matched_df[f'{substance}_before'] = matched_before.loc[common_ids, before_col]
            self.matched_df[f'{substance}_after'] = matched_after.loc[common_ids, after_col]
            
            # 正答フラグ
            correct = self.correct_answers[substance]
            self.matched_df[f'{substance}_before_correct'] = (self.matched_df[f'{substance}_before'] == correct)
            self.matched_df[f'{substance}_after_correct'] = (self.matched_df[f'{substance}_after'] == correct)
        
        # クラス情報
        self.matched_df['class'] = matched_before.loc[common_ids, 'class']
        
        print(f"マッチングデータ作成完了: {len(self.matched_df)}件")
        print()\n        \n    def mcnemar_test_analysis(self):\n        \"\"\"McNemar検定による前後比較\"\"\"\n        print(\"=== McNemar検定による前後比較 ===\")\n        \n        substances = list(self.correct_answers.keys())\n        results = []\n        \n        for substance in substances:\n            before_col = f'{substance}_before_correct'\n            after_col = f'{substance}_after_correct'\n            \n            # 欠損値を除外\n            valid_mask = self.matched_df[before_col].notna() & self.matched_df[after_col].notna()\n            before_data = self.matched_df.loc[valid_mask, before_col]\n            after_data = self.matched_df.loc[valid_mask, after_col]\n            \n            if len(before_data) == 0:\n                continue\n                \n            # 分割表作成\n            # True/True, True/False, False/True, False/False\n            tt = ((before_data == True) & (after_data == True)).sum()\n            tf = ((before_data == True) & (after_data == False)).sum()\n            ft = ((before_data == False) & (after_data == True)).sum()\n            ff = ((before_data == False) & (after_data == False)).sum()\n            \n            contingency_table = np.array([[tt, tf], [ft, ff]])\n            \n            # McNemar検定\n            if tf + ft > 0:  # 変化がある場合のみ\n                try:\n                    result = mcnemar(contingency_table, exact=True)\n                    p_value = result.pvalue\n                    statistic = result.statistic\n                except:\n                    # exactが失敗した場合は近似版\n                    result = mcnemar(contingency_table, exact=False, correction=True)\n                    p_value = result.pvalue\n                    statistic = result.statistic\n            else:\n                p_value = 1.0\n                statistic = 0.0\n            \n            # 正答率計算\n            before_rate = before_data.mean() * 100\n            after_rate = after_data.mean() * 100\n            change = after_rate - before_rate\n            \n            # 効果量（オッズ比）\n            if tf > 0 and ft > 0:\n                odds_ratio = ft / tf\n            elif tf == 0 and ft > 0:\n                odds_ratio = float('inf')\n            elif tf > 0 and ft == 0:\n                odds_ratio = 0.0\n            else:\n                odds_ratio = 1.0\n            \n            results.append({\n                '物質': substance,\n                'N': len(before_data),\n                '授業前正答率': round(before_rate, 1),\n                '授業後正答率': round(after_rate, 1),\n                '変化': round(change, 1),\n                '改善→悪化': tf,\n                '悪化→改善': ft,\n                'McNemar統計量': round(statistic, 3),\n                'p値': round(p_value, 4),\n                'オッズ比': round(odds_ratio, 3) if odds_ratio != float('inf') else 'inf'\n            })\n        \n        results_df = pd.DataFrame(results)\n        print(results_df.to_string(index=False))\n        \n        # 多重比較補正\n        p_values = results_df['p値'].values\n        rejected, p_corrected, alpha_sidak, alpha_bonf = multipletests(\n            p_values, alpha=self.significance_level, method='bonferroni'\n        )\n        \n        results_df['p値_補正'] = np.round(p_corrected, 4)\n        results_df['有意'] = rejected\n        \n        print(f\"\\n=== 多重比較補正結果（Bonferroni法） ===\")\n        print(f\"補正前α = {self.significance_level}\")\n        print(f\"補正後α = {alpha_bonf:.4f}\")\n        \n        significant_results = results_df[results_df['有意']]\n        if len(significant_results) > 0:\n            print(\"\\n有意な変化:\")\n            for _, row in significant_results.iterrows():\n                direction = \"改善\" if row['変化'] > 0 else \"悪化\"\n                print(f\"・{row['物質']}: {row['変化']:+.1f}ポイント ({direction})\" + \n                      f\" p={row['p値_補正']:.4f}\")\n        else:\n            print(\"\\n有意な変化なし\")\n        \n        print()\n        return results_df\n    \n    def calculate_composite_scores(self):\n        \"\"\"総合スコアの計算と対応のあるt検定\"\"\"\n        print(\"=== 総合スコア分析 ===\")\n        \n        substances = list(self.correct_answers.keys())\n        \n        # 各個人の総合スコア計算\n        before_scores = []\n        after_scores = []\n        \n        for idx in self.matched_df.index:\n            before_score = 0\n            after_score = 0\n            valid_items = 0\n            \n            for substance in substances:\n                before_col = f'{substance}_before_correct'\n                after_col = f'{substance}_after_correct'\n                \n                if (pd.notna(self.matched_df.loc[idx, before_col]) and \n                    pd.notna(self.matched_df.loc[idx, after_col])):\n                    before_score += int(self.matched_df.loc[idx, before_col])\n                    after_score += int(self.matched_df.loc[idx, after_col])\n                    valid_items += 1\n            \n            if valid_items >= 4:  # 4項目以上有効な場合のみ\n                before_scores.append(before_score / valid_items * 100)  # パーセント化\n                after_scores.append(after_score / valid_items * 100)\n        \n        before_scores = np.array(before_scores)\n        after_scores = np.array(after_scores)\n        \n        print(f\"総合スコア分析対象: {len(before_scores)}名\")\n        \n        # 記述統計\n        print(f\"\\n=== 記述統計 ===\")\n        print(f\"授業前平均: {before_scores.mean():.1f}% (SD: {before_scores.std():.1f})\")\n        print(f\"授業後平均: {after_scores.mean():.1f}% (SD: {after_scores.std():.1f})\")\n        print(f\"平均変化: {(after_scores - before_scores).mean():.1f}ポイント\")\n        \n        # 対応のあるt検定\n        t_stat, p_value = stats.ttest_rel(after_scores, before_scores)\n        \n        # 効果量（Cohen's d）\n        diff = after_scores - before_scores\n        cohens_d = diff.mean() / diff.std()\n        \n        print(f\"\\n=== 対応のあるt検定 ===\")\n        print(f\"t統計量: {t_stat:.3f}\")\n        print(f\"p値: {p_value:.4f}\")\n        print(f\"効果量 (Cohen's d): {cohens_d:.3f}\")\n        \n        # 効果量の解釈\n        if abs(cohens_d) < 0.2:\n            effect_interpretation = \"小さい\"\n        elif abs(cohens_d) < 0.5:\n            effect_interpretation = \"中程度\"\n        elif abs(cohens_d) < 0.8:\n            effect_interpretation = \"大きい\"\n        else:\n            effect_interpretation = \"非常に大きい\"\n        \n        print(f\"効果量解釈: {effect_interpretation}\")\n        \n        # 95%信頼区間\n        n = len(diff)\n        se = diff.std() / np.sqrt(n)\n        ci_lower = diff.mean() - 1.96 * se\n        ci_upper = diff.mean() + 1.96 * se\n        \n        print(f\"平均変化の95%信頼区間: [{ci_lower:.1f}, {ci_upper:.1f}]\")\n        \n        # 有意性判定\n        is_significant = p_value < self.significance_level\n        print(f\"\\n結果: {'有意' if is_significant else '非有意'} (α = {self.significance_level})\")\n        \n        print()\n        \n        return {\n            'before_scores': before_scores,\n            'after_scores': after_scores,\n            't_statistic': t_stat,\n            'p_value': p_value,\n            'cohens_d': cohens_d,\n            'ci_lower': ci_lower,\n            'ci_upper': ci_upper,\n            'is_significant': is_significant\n        }\n    \n    def power_analysis(self, observed_effect_size=None):\n        \"\"\"サンプルサイズと検出力分析\"\"\"\n        print(\"=== サンプルサイズ・検出力分析 ===\")\n        \n        current_n = len(self.matched_df)\n        \n        if observed_effect_size is None:\n            # 総合スコアから効果量を取得\n            composite_results = self.calculate_composite_scores()\n            observed_effect_size = abs(composite_results['cohens_d'])\n        \n        # 現在のサンプルサイズでの検出力\n        current_power = ttest_power(observed_effect_size, current_n, self.significance_level)\n        \n        # 必要サンプルサイズ（検出力0.8）\n        required_n_80 = pg.power_ttest(d=observed_effect_size, power=0.8, alpha=self.significance_level)\n        required_n_90 = pg.power_ttest(d=observed_effect_size, power=0.9, alpha=self.significance_level)\n        \n        print(f\"観測された効果量: {observed_effect_size:.3f}\")\n        print(f\"現在のサンプルサイズ: {current_n}\")\n        print(f\"現在の検出力: {current_power:.3f}\")\n        print(f\"検出力0.8に必要なN: {required_n_80:.0f}\")\n        print(f\"検出力0.9に必要なN: {required_n_90:.0f}\")\n        \n        # 効果量別必要サンプルサイズ\n        print(f\"\\n=== 効果量別必要サンプルサイズ（検出力0.8） ===\")\n        for d in [0.2, 0.5, 0.8]:\n            n_needed = pg.power_ttest(d=d, power=0.8, alpha=self.significance_level)\n            interpretation = [\"小\", \"中\", \"大\"][int(d*5-1)]\n            print(f\"効果量 {d} ({interpretation}): N = {n_needed:.0f}\")\n        \n        print()\n        \n        return {\n            'current_n': current_n,\n            'observed_effect_size': observed_effect_size,\n            'current_power': current_power,\n            'required_n_80': required_n_80,\n            'required_n_90': required_n_90\n        }\n    \n    def q3_tea_analysis(self):\n        \"\"\"Q3（お茶の理解度）の詳細分析\"\"\"\n        print(\"=== Q3 お茶の理解度分析 ===\")\n        \n        # Q3項目の確認\n        q3_cols_before = [col for col in self.before_df.columns if 'Q3_' in col]\n        q3_cols_after = [col for col in self.after_df.columns if 'Q3_' in col]\n        \n        print(f\"授業前Q3項目: {q3_cols_before}\")\n        print(f\"授業後Q3項目: {q3_cols_after}\")\n        \n        if not q3_cols_before or not q3_cols_after:\n            print(\"Q3項目が見つかりません\")\n            return\n        \n        # 項目対応（仮定）\n        q3_mapping = []\n        for before_col in q3_cols_before:\n            for after_col in q3_cols_after:\n                if 'Dissolve' in before_col and 'Dissolve' in after_col:\n                    if ('Leaves' in before_col and 'Leaves' in after_col) or \\\n                       ('Components' in before_col and 'Components' in after_col):\n                        q3_mapping.append((before_col, after_col))\n        \n        if not q3_mapping:\n            print(\"Q3項目の対応関係が見つかりません\")\n            return\n        \n        print(f\"\\nQ3項目対応関係:\")\n        results = []\n        \n        for before_col, after_col in q3_mapping:\n            print(f\"{before_col} ↔ {after_col}\")\n            \n            # マッチングデータの作成\n            matched_before = self.before_df.set_index('Page_ID')\n            matched_after = self.after_df.set_index('Page_ID')\n            common_ids = matched_before.index.intersection(matched_after.index)\n            \n            before_data = matched_before.loc[common_ids, before_col]\n            after_data = matched_after.loc[common_ids, after_col]\n            \n            # 有効データのフィルタリング\n            valid_mask = before_data.notna() & after_data.notna()\n            before_valid = before_data[valid_mask]\n            after_valid = after_data[valid_mask]\n            \n            if len(before_valid) == 0:\n                continue\n            \n            # McNemar検定\n            tt = ((before_valid == True) & (after_valid == True)).sum()\n            tf = ((before_valid == True) & (after_valid == False)).sum()\n            ft = ((before_valid == False) & (after_valid == True)).sum()\n            ff = ((before_valid == False) & (after_valid == False)).sum()\n            \n            contingency_table = np.array([[tt, tf], [ft, ff]])\n            \n            if tf + ft > 0:\n                try:\n                    result = mcnemar(contingency_table, exact=True)\n                    p_value = result.pvalue\n                    statistic = result.statistic\n                except:\n                    result = mcnemar(contingency_table, exact=False, correction=True)\n                    p_value = result.pvalue\n                    statistic = result.statistic\n            else:\n                p_value = 1.0\n                statistic = 0.0\n            \n            before_rate = before_valid.mean() * 100\n            after_rate = after_valid.mean() * 100\n            change = after_rate - before_rate\n            \n            results.append({\n                '項目': after_col.replace('Q3_', '').replace('_', ' '),\n                'N': len(before_valid),\n                '授業前正答率': round(before_rate, 1),\n                '授業後正答率': round(after_rate, 1),\n                '変化': round(change, 1),\n                'p値': round(p_value, 4)\n            })\n        \n        if results:\n            results_df = pd.DataFrame(results)\n            print(f\"\\nQ3項目分析結果:\")\n            print(results_df.to_string(index=False))\n        \n        print()\n        return results\n    \n    def create_visualization(self, mcnemar_results, composite_results):\n        \"\"\"結果の可視化\"\"\"\n        print(\"=== 結果可視化 ===\")\n        \n        # 1. McNemar検定結果の可視化\n        fig, axes = plt.subplots(2, 2, figsize=(16, 12))\n        \n        # 正答率変化の棒グラフ\n        substances = mcnemar_results['物質']\n        changes = mcnemar_results['変化']\n        colors = ['red' if x < 0 else 'blue' for x in changes]\n        \n        axes[0,0].bar(substances, changes, color=colors, alpha=0.7)\n        axes[0,0].set_title('Q1項目 正答率変化')\n        axes[0,0].set_ylabel('変化（ポイント）')\n        axes[0,0].axhline(y=0, color='black', linestyle='-', alpha=0.3)\n        axes[0,0].tick_params(axis='x', rotation=45)\n        \n        # 有意性の表示\n        for i, (substance, change, significant) in enumerate(zip(substances, changes, mcnemar_results['有意'])):\n            if significant:\n                axes[0,0].text(i, change + (1 if change >= 0 else -1), '*', \n                              ha='center', va='bottom' if change >= 0 else 'top', \n                              fontsize=16, color='red')\n        \n        # 授業前後正答率の比較\n        x = np.arange(len(substances))\n        width = 0.35\n        \n        axes[0,1].bar(x - width/2, mcnemar_results['授業前正答率'], width, \n                     label='授業前', alpha=0.7)\n        axes[0,1].bar(x + width/2, mcnemar_results['授業後正答率'], width, \n                     label='授業後', alpha=0.7)\n        axes[0,1].set_title('授業前後正答率比較')\n        axes[0,1].set_ylabel('正答率 (%)')\n        axes[0,1].set_xticks(x)\n        axes[0,1].set_xticklabels(substances, rotation=45)\n        axes[0,1].legend()\n        \n        # 総合スコアの散布図\n        before_scores = composite_results['before_scores']\n        after_scores = composite_results['after_scores']\n        \n        axes[1,0].scatter(before_scores, after_scores, alpha=0.6)\n        min_score = min(before_scores.min(), after_scores.min())\n        max_score = max(before_scores.max(), after_scores.max())\n        axes[1,0].plot([min_score, max_score], [min_score, max_score], 'r--', alpha=0.5)\n        axes[1,0].set_xlabel('授業前総合スコア (%)')\n        axes[1,0].set_ylabel('授業後総合スコア (%)')\n        axes[1,0].set_title('個人別総合スコア変化')\n        \n        # 変化量のヒストグラム\n        changes_individual = after_scores - before_scores\n        axes[1,1].hist(changes_individual, bins=15, alpha=0.7, edgecolor='black')\n        axes[1,1].axvline(x=0, color='red', linestyle='--', alpha=0.7)\n        axes[1,1].axvline(x=changes_individual.mean(), color='blue', linestyle='-', \n                         label=f'平均: {changes_individual.mean():.1f}')\n        axes[1,1].set_xlabel('総合スコア変化 (ポイント)')\n        axes[1,1].set_ylabel('人数')\n        axes[1,1].set_title('個人別スコア変化分布')\n        axes[1,1].legend()\n        \n        plt.tight_layout()\n        \n        # ファイル保存\n        output_dir = 'reports/2025-05-30/'\n        os.makedirs(output_dir, exist_ok=True)\n        plt.savefig(os.path.join(output_dir, 'phase2_statistical_results.png'), \n                   dpi=300, bbox_inches='tight')\n        print(f\"図表保存: {output_dir}phase2_statistical_results.png\")\n        \n        plt.show()\n    \n    def generate_phase2_summary(self, mcnemar_results, composite_results, power_results):\n        \"\"\"Phase 2 結果サマリー\"\"\"\n        print(\"=\" * 60)\n        print(\"Phase 2 教育効果の統計的検証 結果サマリー\")\n        print(\"=\" * 60)\n        \n        print(f\"\\n📊 分析概要:\")\n        print(f\"・分析対象: {len(self.matched_df)}名の前後マッチングデータ\")\n        print(f\"・検定項目: Q1水溶液認識6項目 + 総合スコア\")\n        print(f\"・有意水準: α = {self.significance_level}\")\n        print(f\"・多重比較補正: Bonferroni法\")\n        \n        print(f\"\\n🔍 McNemar検定結果:\")\n        significant_items = mcnemar_results[mcnemar_results['有意']]\n        if len(significant_items) > 0:\n            print(f\"・有意な変化: {len(significant_items)}/{len(mcnemar_results)}項目\")\n            for _, row in significant_items.iterrows():\n                direction = \"改善\" if row['変化'] > 0 else \"悪化\"\n                print(f\"  - {row['物質']}: {row['変化']:+.1f}ポイント ({direction}, p={row['p値_補正']:.4f})\")\n        else:\n            print(\"・有意な変化: なし\")\n        \n        # 改善傾向の項目\n        improved_items = mcnemar_results[mcnemar_results['変化'] > 0]\n        print(f\"・改善傾向: {len(improved_items)}/{len(mcnemar_results)}項目\")\n        if len(improved_items) > 0:\n            for _, row in improved_items.iterrows():\n                sig = \" *\" if row['有意'] else \"\"\n                print(f\"  - {row['物質']}: +{row['変化']:.1f}ポイント{sig}\")\n        \n        print(f\"\\n📈 総合スコア分析:\")\n        print(f\"・平均変化: {(composite_results['after_scores'] - composite_results['before_scores']).mean():.1f}ポイント\")\n        print(f\"・効果量 (Cohen's d): {composite_results['cohens_d']:.3f}\")\n        print(f\"・統計的有意性: {'有意' if composite_results['is_significant'] else '非有意'} (p={composite_results['p_value']:.4f})\")\n        print(f\"・95%信頼区間: [{composite_results['ci_lower']:.1f}, {composite_results['ci_upper']:.1f}]\")\n        \n        print(f\"\\n⚡ 検出力分析:\")\n        print(f\"・現在の検出力: {power_results['current_power']:.3f}\")\n        print(f\"・検出力0.8に必要なN: {power_results['required_n_80']:.0f}名\")\n        \n        adequacy = \"十分\" if power_results['current_power'] >= 0.8 else \"不足\"\n        print(f\"・サンプルサイズ: {adequacy}\")\n        \n        print(f\"\\n✅ Phase 2 完了判定:\")\n        \n        # 主要仮説の検証\n        hypothesis_results = []\n        \n        # 仮説1: 授業後の水溶液理解度は有意に向上する\n        overall_improvement = composite_results['is_significant'] and composite_results['cohens_d'] > 0\n        hypothesis_results.append((\"仮説1（全体的改善）\", \"支持\" if overall_improvement else \"棄却\"))\n        \n        # 仮説2（効果量）: d > 0.5の期待\n        large_effect = abs(composite_results['cohens_d']) > 0.5\n        hypothesis_results.append((\"仮説2（大きな効果）\", \"支持\" if large_effect else \"棄却\"))\n        \n        # 個別項目での改善\n        any_significant = len(significant_items) > 0\n        hypothesis_results.append((\"個別項目改善\", \"確認\" if any_significant else \"未確認\"))\n        \n        for hypothesis, result in hypothesis_results:\n            status = \"🟢\" if result in [\"支持\", \"確認\"] else \"🟡\"\n            print(f\"{status} {hypothesis}: {result}\")\n        \n        print(f\"\\n🎯 主要な知見:\")\n        \n        # 特に改善が見られた領域\n        non_solution_items = mcnemar_results[mcnemar_results['物質'].isin(['Muddywater', 'Ink'])]\n        if len(non_solution_items) > 0:\n            avg_non_solution_change = non_solution_items['変化'].mean()\n            print(f\"・非水溶液の理解が大幅改善 (平均+{avg_non_solution_change:.1f}ポイント)\")\n        \n        solution_items = mcnemar_results[mcnemar_results['物質'].isin(['MisoSoup', 'SoySauce'])]\n        if len(solution_items) > 0:\n            avg_solution_change = solution_items['変化'].mean()\n            if avg_solution_change < 0:\n                print(f\"・日常的水溶液で課題あり (平均{avg_solution_change:.1f}ポイント)\")\n        \n        print(f\"\\n🔄 次ステップ:\")\n        if any_significant or overall_improvement:\n            print(\"🟢 Phase 3 (集団間差異分析) に進行\")\n        else:\n            print(\"🟡 効果が限定的 - Phase 3で詳細分析を実施\")\n        \n        print(\"=\" * 60)\n        \n        return {\n            'significant_items': len(significant_items),\n            'improved_items': len(improved_items),\n            'overall_significant': composite_results['is_significant'],\n            'effect_size': composite_results['cohens_d'],\n            'power_adequate': power_results['current_power'] >= 0.8\n        }\n    \n    def run_full_analysis(self):\n        \"\"\"Phase 2 フル分析の実行\"\"\"\n        print(\"Phase 2: 教育効果の統計的検証 実行開始\")\n        print(\"=\" * 60)\n        \n        # 1. データ準備\n        self.load_and_prepare_data()\n        \n        # 2. McNemar検定\n        mcnemar_results = self.mcnemar_test_analysis()\n        \n        # 3. 総合スコア分析\n        composite_results = self.calculate_composite_scores()\n        \n        # 4. 検出力分析\n        power_results = self.power_analysis(observed_effect_size=abs(composite_results['cohens_d']))\n        \n        # 5. Q3分析（あれば）\n        q3_results = self.q3_tea_analysis()\n        \n        # 6. 可視化\n        self.create_visualization(mcnemar_results, composite_results)\n        \n        # 7. 結果サマリー\n        summary = self.generate_phase2_summary(mcnemar_results, composite_results, power_results)\n        \n        return {\n            'mcnemar_results': mcnemar_results,\n            'composite_results': composite_results,\n            'power_results': power_results,\n            'q3_results': q3_results,\n            'summary': summary\n        }\n\ndef main():\n    \"\"\"メイン実行関数\"\"\"\n    analyzer = Phase2StatisticalTesting()\n    results = analyzer.run_full_analysis()\n    \n    print(\"\\n🎉 Phase 2 統計的検証完了!\")\n    \n    if results['summary']['overall_significant'] or results['summary']['significant_items'] > 0:\n        print(\"✅ 教育効果を統計的に確認\")\n        print(\"次ステップ: Phase 3 (集団間差異分析) の実行\")\n    else:\n        print(\"ℹ️ 全体的な効果は限定的\")\n        print(\"次ステップ: Phase 3での詳細分析で要因を探索\")\n    \n    return results\n\nif __name__ == \"__main__\":\n    results = main()